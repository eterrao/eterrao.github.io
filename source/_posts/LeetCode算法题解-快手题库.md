---
title: LeetCode算法题解--快手题库
date: 2021-02-23 11:48:20
tags: 面试, LeetCode, 刷题
---

### 顺序按照出题频率高到低

| 题目                                                         | 通过率 | 难度 |
| :----------------------------------------------------------- | :----- | :--- |
| [165. 比较版本号](https://leetcode-cn.com/problems/compare-version-numbers/)[字符串](https://leetcode-cn.com/tag/string/) | 45.1%  | 中等 |
| [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)[数组](https://leetcode-cn.com/tag/array/)[二分查找](https://leetcode-cn.com/tag/binary-search/)1+ | 39.6%  | 困难 |
| [202. 快乐数](https://leetcode-cn.com/problems/happy-number/)[哈希表](https://leetcode-cn.com/tag/hash-table/)[数学](https://leetcode-cn.com/tag/math/) | 61.2%  | 简单 |
| [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)[数组](https://leetcode-cn.com/tag/array/)[二分查找](https://leetcode-cn.com/tag/binary-search/) | 40.6%  | 中等 |
| [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)[递归](https://leetcode-cn.com/tag/recursion/)[链表](https://leetcode-cn.com/tag/linked-list/) | 65.4%  | 简单 |
| [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)[字符串](https://leetcode-cn.com/tag/string/)[动态规划](https://leetcode-cn.com/tag/dynamic-programming/) | 60.5%  | 困难 |
| [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)[深度优先搜索](https://leetcode-cn.com/tag/depth-first-search/)[递归](https://leetcode-cn.com/tag/recursion/)2+ | 55.9%  | 中等 |
| [1254. 统计封闭岛屿的数目](https://leetcode-cn.com/problems/number-of-closed-islands/)[深度优先搜索](https://leetcode-cn.com/tag/depth-first-search/) | 58.9%  | 中等 |
| [415. 字符串相加](https://leetcode-cn.com/problems/add-strings/)[字符串](https://leetcode-cn.com/tag/string/) | 51.9%  | 简单 |
| [468. 验证IP地址](https://leetcode-cn.com/problems/validate-ip-address/)[字符串](https://leetcode-cn.com/tag/string/) | 23.4%  | 中等 |
| [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)[数组](https://leetcode-cn.com/tag/array/)[双指针](https://leetcode-cn.com/tag/two-pointers/) | 49.4%  | 简单 |
| [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)[设计](https://leetcode-cn.com/tag/design/) | 51.7%  | 中等 |
| [剑指 Offer 24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)[链表](https://leetcode-cn.com/tag/linked-list/) | 74.3%  | 简单 |
| [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)[链表](https://leetcode-cn.com/tag/linked-list/) | 71.4%  | 简单 |
| [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)[并查集](https://leetcode-cn.com/tag/union-find/)[数组](https://leetcode-cn.com/tag/array/) | 52.8%  | 困难 |
| [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)[排序](https://leetcode-cn.com/tag/sort/)[链表](https://leetcode-cn.com/tag/linked-list/) | 67.5%  | 中等 |
| [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)[二分查找](https://leetcode-cn.com/tag/binary-search/)[动态规划](https://leetcode-cn.com/tag/dynamic-programming/) | 47.2%  | 中等 |
| [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)[数组](https://leetcode-cn.com/tag/array/)[动态规划](https://leetcode-cn.com/tag/dynamic-programming/) | 68.2%  | 中等 |
| [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)[哈希表](https://leetcode-cn.com/tag/hash-table/)[双指针](https://leetcode-cn.com/tag/two-pointers/)2+ | 36.4%  | 中等 |
| [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)[链表](https://leetcode-cn.com/tag/linked-list/) | 52.3%  | 中等 |
| [15. 三数之和](https://leetcode-cn.com/problems/3sum/)[数组](https://leetcode-cn.com/tag/array/)[双指针](https://leetcode-cn.com/tag/two-pointers/) | 31.0%  | 中等 |
| [1. 两数之和](https://leetcode-cn.com/problems/two-sum/) [数组](https://leetcode-cn.com/tag/array/) [哈希表](https://leetcode-cn.com/tag/hash-table/) | 50.2%  | 简单 |
| [46. 全排列](https://leetcode-cn.com/problems/permutations/)[回溯算法](https://leetcode-cn.com/tag/backtracking/) | 77.6%  | 中等 |
| [78. 子集](https://leetcode-cn.com/problems/subsets/)[位运算](https://leetcode-cn.com/tag/bit-manipulation/)[数组](https://leetcode-cn.com/tag/array/)1+ | 79.5%  | 中等 |
| [82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)[链表](https://leetcode-cn.com/tag/linked-list/) | 50.3%  | 中等 |
| [1046. 最后一块石头的重量](https://leetcode-cn.com/problems/last-stone-weight/)[堆](https://leetcode-cn.com/tag/heap/)[贪心算法](https://leetcode-cn.com/tag/greedy/) | 65.9%  | 简单 |
| [93. 复原IP地址](https://leetcode-cn.com/problems/restore-ip-addresses/)[字符串](https://leetcode-cn.com/tag/string/)[回溯算法](https://leetcode-cn.com/tag/backtracking/) | 51.6%  | 中等 |
| [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)[数组](https://leetcode-cn.com/tag/array/)[动态规划](https://leetcode-cn.com/tag/dynamic-programming/) | 56.0%  | 简单 |
| [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)[树](https://leetcode-cn.com/tag/tree/) | 52.2%  | 简单 |
| [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)[数组](https://leetcode-cn.com/tag/array/)[分治算法](https://leetcode-cn.com/tag/divide-and-conquer/)1+ | 53.3%  | 简单 |
| [1027. 最长等差数列](https://leetcode-cn.com/problems/longest-arithmetic-subsequence/)[动态规划](https://leetcode-cn.com/tag/dynamic-programming/) | 44.1%  | 中等 |
| [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)[树](https://leetcode-cn.com/tag/tree/)[深度优先搜索](https://leetcode-cn.com/tag/depth-first-search/)1+ | 33.6%  | 中等 |
| [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)[字符串](https://leetcode-cn.com/tag/string/)[动态规划](https://leetcode-cn.com/tag/dynamic-programming/) | 33.1%  | 中等 |
| [6. Z 字形变换](https://leetcode-cn.com/problems/zigzag-conversion/)[字符串](https://leetcode-cn.com/tag/string/) | 49.6%  | 中等 |
| [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)[树](https://leetcode-cn.com/tag/tree/)[深度优先搜索](https://leetcode-cn.com/tag/depth-first-search/)3+ | 64.9%  | 中等 |
| [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)[堆](https://leetcode-cn.com/tag/heap/)[分治算法](https://leetcode-cn.com/tag/divide-and-conquer/) | 64.8%  | 中等 |
| [面试题 16.25. LRU 缓存](https://leetcode-cn.com/problems/lru-cache-lcci/)[设计](https://leetcode-cn.com/tag/design/) | 53.7%  | 中等 |
| [540. 有序数组中的单一元素](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/)[二分查找](https://leetcode-cn.com/tag/binary-search/) | 59.3%  | 中等 |
| [7. 整数反转](https://leetcode-cn.com/problems/reverse-integer/)[数学](https://leetcode-cn.com/tag/math/) | 35.0%  | 简单 |
| [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)[树](https://leetcode-cn.com/tag/tree/) | 66.4%  | 中等 |
| [69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/)[数学](https://leetcode-cn.com/tag/math/)[二分查找](https://leetcode-cn.com/tag/binary-search/) | 39.2%  | 简单 |
| [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)[树](https://leetcode-cn.com/tag/tree/)[深度优先搜索](https://leetcode-cn.com/tag/depth-first-search/)1+ | 69.2%  | 中等 |
| [572. 另一个树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/)[树](https://leetcode-cn.com/tag/tree/) | 47.3%  | 简单 |
| [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)[栈](https://leetcode-cn.com/tag/stack/)[设计](https://leetcode-cn.com/tag/design/) | 56.3%  | 简单 |
| [面试题 10.01. 合并排序的数组](https://leetcode-cn.com/problems/sorted-merge-lcci/)[数组](https://leetcode-cn.com/tag/array/)[双指针](https://leetcode-cn.com/tag/two-pointers/) | 54.6%  | 简单 |
| [240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)[二分查找](https://leetcode-cn.com/tag/binary-search/)[分治算法](https://leetcode-cn.com/tag/divide-and-conquer/) | 44.0%  | 中等 |
| [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)[递归](https://leetcode-cn.com/tag/recursion/)[链表](https://leetcode-cn.com/tag/linked-list/)1+ | 39.5%  | 中等 |
| [41. 缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/)[数组](https://leetcode-cn.com/tag/array/) | 40.6%  | 困难 |
| [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)[数组](https://leetcode-cn.com/tag/array/)[动态规划](https://leetcode-cn.com/tag/dynamic-programming/) | 41.0%  | 中等 |
| [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)[排序](https://leetcode-cn.com/tag/sort/)[数组](https://leetcode-cn.com/tag/array/) | 44.4%  | 中等 |
| [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)[链表](https://leetcode-cn.com/tag/linked-list/)[双指针](https://leetcode-cn.com/tag/two-pointers/) | 78.6%  | 简单 |
| [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)[数组](https://leetcode-cn.com/tag/array/)[双指针](https://leetcode-cn.com/tag/two-pointers/) | 64.7%  | 中等 |
| [剑指 Offer 25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)[分治算法](https://leetcode-cn.com/tag/divide-and-conquer/) | 73.0%  | 简单 |
| [1397. 找到所有好字符串](https://leetcode-cn.com/problems/find-all-good-strings/)[动态规划](https://leetcode-cn.com/tag/dynamic-programming/) | 34.9%  | 困难 |
| [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)[广度优先搜索](https://leetcode-cn.com/tag/breadth-first-search/)[数学](https://leetcode-cn.com/tag/math/)1+ | 59.2%  | 中等 |
| [50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)[数学](https://leetcode-cn.com/tag/math/)[二分查找](https://leetcode-cn.com/tag/binary-search/) | 37.3%  | 中等 |
| [919. 完全二叉树插入器](https://leetcode-cn.com/problems/complete-binary-tree-inserter/)[树](https://leetcode-cn.com/tag/tree/) | 61.7%  | 中等 |
| [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)[深度优先搜索](https://leetcode-cn.com/tag/depth-first-search/)[广度优先搜索](https://leetcode-cn.com/tag/breadth-first-search/)1+ | 52.4%  | 中等 |
| [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)[字符串](https://leetcode-cn.com/tag/string/)[动态规划](https://leetcode-cn.com/tag/dynamic-programming/) | 34.6%  | 困难 |
| [剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)[分治算法](https://leetcode-cn.com/tag/divide-and-conquer/)[动态规划](https://leetcode-cn.com/tag/dynamic-programming/) | 60.0%  | 简单 |
| [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)[堆](https://leetcode-cn.com/tag/heap/)[Sliding Window](https://leetcode-cn.com/tag/sliding-window/) | 49.6%  | 困难 |
| [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)[数组](https://leetcode-cn.com/tag/array/) | 42.8%  | 中等 |
| [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)[链表](https://leetcode-cn.com/tag/linked-list/)[双指针](https://leetcode-cn.com/tag/two-pointers/) | 45.5%  | 简单 |
| [14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)[字符串](https://leetcode-cn.com/tag/string/) | 39.2%  | 简单 |
| [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)[栈](https://leetcode-cn.com/tag/stack/)[数组](https://leetcode-cn.com/tag/array/)2+ | 54.4%  | 困难 |
| [面试题 16.26. 计算器](https://leetcode-cn.com/problems/calculator-lcci/)[字符串](https://leetcode-cn.com/tag/string/) | 37.8%  | 中等 |
| [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)[数组](https://leetcode-cn.com/tag/array/)[二分查找](https://leetcode-cn.com/tag/binary-search/) | 42.2%  | 中等 |
| [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)[排序](https://leetcode-cn.com/tag/sort/)[数组](https://leetcode-cn.com/tag/array/)1+ | 57.5%  | 中等 |
| [149. 直线上最多的点数](https://leetcode-cn.com/problems/max-points-on-a-line/)[哈希表](https://leetcode-cn.com/tag/hash-table/)[数学](https://leetcode-cn.com/tag/math/) | 23.6%  | 困难 |
| [44. 通配符匹配](https://leetcode-cn.com/problems/wildcard-matching/)[贪心算法](https://leetcode-cn.com/tag/greedy/)[字符串](https://leetcode-cn.com/tag/string/)2+ | 31.9%  | 困难 |
| [1339. 分裂二叉树的最大乘积](https://leetcode-cn.com/problems/maximum-product-of-splitted-binary-tree/)[树](https://leetcode-cn.com/tag/tree/)[动态规划](https://leetcode-cn.com/tag/dynamic-programming/) | 39.3%  | 中等 |
| [面试题 01.07. 旋转矩阵](https://leetcode-cn.com/problems/rotate-matrix-lcci/)[数组](https://leetcode-cn.com/tag/array/) | 75.9%  | 中等 |
| [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)[树](https://leetcode-cn.com/tag/tree/) | 46.0%  | 中等 |
| [1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)[动态规划](https://leetcode-cn.com/tag/dynamic-programming/) | 50.1%  | 中等 |
| [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)[堆](https://leetcode-cn.com/tag/heap/)[链表](https://leetcode-cn.com/tag/linked-list/)1+ | 54.3%  | 困难 |
| [179. 最大数](https://leetcode-cn.com/problems/largest-number/)[排序](https://leetcode-cn.com/tag/sort/) | 37.9%  | 中等 |
| [48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)[数组](https://leetcode-cn.com/tag/array/) | 72.3%  | 中等 |
| [面试题 02.02. 返回倒数第 k 个节点](https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/)[链表](https://leetcode-cn.com/tag/linked-list/)[双指针](https://leetcode-cn.com/tag/two-pointers/) | 78.0%  | 简单 |
| [1097. 游戏玩法分析 V](https://leetcode-cn.com/problems/game-play-analysis-v/)![plus](https://static.leetcode-cn.com/cn-mono-assets/production/assets/plus.31398c34.svg) | 51.4%  | 困难 |
| [剑指 Offer 66. 构建乘积数组](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/) | 59.2%  | 中等 |
| [445. 两数相加 II](https://leetcode-cn.com/problems/add-two-numbers-ii/)[链表](https://leetcode-cn.com/tag/linked-list/) | 58.3%  | 中等 |
| [560. 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)[数组](https://leetcode-cn.com/tag/array/)[哈希表](https://leetcode-cn.com/tag/hash-table/) | 44.9%  | 中等 |
| [面试题 02.05. 链表求和](https://leetcode-cn.com/problems/sum-lists-lcci/)[链表](https://leetcode-cn.com/tag/linked-list/)[数学](https://leetcode-cn.com/tag/math/) | 46.4%  | 中等 |
| [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)[位运算](https://leetcode-cn.com/tag/bit-manipulation/)[数组](https://leetcode-cn.com/tag/array/)1+ | 65.7%  | 简单 |
| [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)[树](https://leetcode-cn.com/tag/tree/) | 66.1%  | 简单 |
| [171. Excel表列序号](https://leetcode-cn.com/problems/excel-sheet-column-number/)[数学](https://leetcode-cn.com/tag/math/) | 68.9%  | 简单 |
| [剑指 Offer 14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)[数学](https://leetcode-cn.com/tag/math/)[动态规划](https://leetcode-cn.com/tag/dynamic-programming/) | 56.0%  | 中等 |
| [1114. 按序打印](https://leetcode-cn.com/problems/print-in-order/) | 64.7%  | 简单 |
| [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)[栈](https://leetcode-cn.com/tag/stack/)[字符串](https://leetcode-cn.com/tag/string/) | 43.7%  | 简单 |
| [746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)[数组](https://leetcode-cn.com/tag/array/)[动态规划](https://leetcode-cn.com/tag/dynamic-programming/) | 54.8%  | 简单 |
| [剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)[链表](https://leetcode-cn.com/tag/linked-list/) | 63.5%  | 简单 |
| [135. 分发糖果](https://leetcode-cn.com/problems/candy/)[贪心算法](https://leetcode-cn.com/tag/greedy/) | 48.2%  | 困难 |
| [剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)[分治算法](https://leetcode-cn.com/tag/divide-and-conquer/) | 64.9%  | 中等 |
| [470. 用 Rand7() 实现 Rand10()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)[Random](https://leetcode-cn.com/tag/random/)[Rejection Sampling](https://leetcode-cn.com/tag/rejection-sampling/) | 52.6%  | 中等 |
| [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)[树](https://leetcode-cn.com/tag/tree/)[深度优先搜索](https://leetcode-cn.com/tag/depth-first-search/) | 66.6%  | 简单 |
| [剑指 Offer 48. 最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)[哈希表](https://leetcode-cn.com/tag/hash-table/)[双指针](https://leetcode-cn.com/tag/two-pointers/)1+ | 46.2%  | 中等 |
| [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)[数组](https://leetcode-cn.com/tag/array/) | 78.5%  | 中等 |
| [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)[链表](https://leetcode-cn.com/tag/linked-list/) | 59.5%  | 中等 |
| [103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)[栈](https://leetcode-cn.com/tag/stack/)[树](https://leetcode-cn.com/tag/tree/)1+ | 57.1%  | 中等 |
| [剑指 Offer 58 - I. 翻转单词顺序](https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/)[字符串](https://leetcode-cn.com/tag/string/) | 43.7%  | 简单 |

#### [165. 比较版本号](https://leetcode-cn.com/problems/compare-version-numbers/)

难度 中等

> 给你两个版本号 `version1` 和 `version2` ，请你比较它们。
>
> 版本号由一个或多个修订号组成，各修订号由一个 `'.'` 连接。每个修订号由 **多位数字** 组成，可能包含 **前导零** 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，`2.5.33` 和 `0.1` 都是有效的版本号。
>
> 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 **忽略任何前导零后的整数值** 。也就是说，修订号 `1` 和修订号 `001` **相等** 。如果版本号没有指定某个下标处的修订号，则该修订号视为 `0` 。例如，版本 `1.0` 小于版本 `1.1` ，因为它们下标为 `0` 的修订号相同，而下标为 `1` 的修订号分别为 `0` 和 `1` ，`0 < 1` 。
>
> 返回规则如下：
>
> - 如果 `*version1* > *version2*` 返回 `1`，
> - 如果 `*version1* < *version2*` 返回 `-1`，
> - 除此之外返回 `0`。
>
> **示例 1：**
>
> ```
> 输入：version1 = "1.01", version2 = "1.001"
> 输出：0
> 解释：忽略前导零，"01" 和 "001" 都表示相同的整数 "1"
> ```
>
> **示例 2：**
>
> ```
> 输入：version1 = "1.0", version2 = "1.0.0"
> 输出：0
> 解释：version1 没有指定下标为 2 的修订号，即视为 "0"
> ```
>
> **示例 3：**
>
> ```
> 输入：version1 = "0.1", version2 = "1.1"
> 输出：-1
> 解释：version1 中下标为 0 的修订号是 "0"，version2 中下标为 0 的修订号是 "1" 。0 < 1，所以 version1 < version2
> ```
>
> **示例 4：**
>
> ```
> 输入：version1 = "1.0.1", version2 = "1"
> 输出：1
> ```
>
> **示例 5：**
>
> ```
> 输入：version1 = "7.5.2.4", version2 = "7.5.3"
> 输出：-1
> ```
>
> **提示：**
>
> - `1 <= version1.length, version2.length <= 500`
> - `version1` 和 `version2` 仅包含数字和 `'.'`
> - `version1` 和 `version2` 都是 **有效版本号**
> - `version1` 和 `version2` 的所有修订号都可以存储在 **32 位整数** 中

### 题解

#### 方法二：双指针，一次遍历，常数空间

方法一有两个缺点：

是两次遍历的解决方法。
消耗线性空间。
我们能否实现一个只有一次遍历和消耗常数空间的解决方法呢？

其思想是在每个字符串上使用两个指针，跟踪每个数组的开始和结束。

这样，可以并行地沿着两个字符串移动，检索并比较相应的块。一旦两个字符串都被解析，比较也就完成了。

算法：

首先，我们定义了一个名为 `get_next_chunk(version, n, p)` 的函数，用于检索字符串中的下一个块。这个函数有三个参数：输入字符串 version，它的长度 n，以及指针 p 为要检索块的第一个字符。它在指针 p 和下一个点之间返回一个整数块。为了帮助迭代，返回的是下一个快的第一个字符的指针。下面是如何使用此函数解决问题的方法：

指针 p1 和 p2 分别指向 version1 和 version2 的起始位置：p1=p2=0。
并行遍历两个字符串。当 p1 < n1 or p2 < n2：
使用 get_next_chunk 函数获取 version1 和 version2 的下一个块 i1 和 i2。
比较 i1 和 i2。如果不相同，则返回 1 或 -1。
如果到了这里，说明版本号相同，则返回 0。
下面实现 `get_next_chunk(version, n, p)` 函数：

块的开头由指针 p 标记。如果 p 设置为字符串的结尾，则字符串解析完成。若要继续比较，则在添加 .0 返回。
如果 p 不在字符串的末尾，则沿字符串移动指针 p_end 以查找块的结尾。
返回块 version.substring(p, p_end)。

```java
class Solution {
  public Pair<Integer, Integer> getNextChunk(String version, int n, int p) {
    // if pointer is set to the end of string
    // return 0
    if (p > n - 1) {
      return new Pair(0, p);
    }
    // find the end of chunk
    int i, pEnd = p;
    while (pEnd < n && version.charAt(pEnd) != '.') {
      ++pEnd;
    }
    // retrieve the chunk
    if (pEnd != n - 1) {
      i = Integer.parseInt(version.substring(p, pEnd));
    } else {
      i = Integer.parseInt(version.substring(p, n));
    }
    // find the beginning of next chunk
    p = pEnd + 1;

    return new Pair(i, p);
  }

  public int compareVersion(String version1, String version2) {
    int p1 = 0, p2 = 0;
    int n1 = version1.length(), n2 = version2.length();

    // compare versions
    int i1, i2;
    Pair<Integer, Integer> pair;
    while (p1 < n1 || p2 < n2) {
      pair = getNextChunk(version1, n1, p1);
      i1 = pair.getKey();
      p1 = pair.getValue();

      pair = getNextChunk(version2, n2, p2);
      i2 = pair.getKey();
      p2 = pair.getValue();
      if (i1 != i2) {
        return i1 > i2 ? 1 : -1;
      }
    }
    // the versions are equal
    return 0;
  }
}

作者：LeetCode
链接：https://leetcode-cn.com/problems/compare-version-numbers/solution/bi-jiao-ban-ben-hao-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

---

#### [202. 快乐数](https://leetcode-cn.com/problems/happy-number/)

难度 简单

编写一个算法来判断一个数 `n` 是不是快乐数。

「快乐数」定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果 **可以变为** 1，那么这个数就是快乐数。

如果 `n` 是快乐数就返回 `true` ；不是，则返回 `false` 。

**示例 1：**

```
输入：19
输出：true
解释：
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
```

**示例 2：**

```
输入：n = 2
输出：false
```

**提示：**

- `1 <= n <= 2^31 - 1`

### 题解

```java
class Solution {
    // 数学解法
    // public boolean isHappy(int n) {
    //     // 解法 1： 直接硬算出不是快乐数的数组元素，再套结果
    //     // 非快乐数必然只有这个数组中的结果，并且是个死循环
    //     Integer[] numbers = new Integer[]{37, 58, 89, 145, 42, 20, 4};
    //     HashSet<Integer> circles = new HashSet<>(Arrays.asList(numbers));
    //     while (!circles.contains(getNext(n)) && n != 1) {
    //         n = getNext(n);
    //     }
    //     return n == 1;
    // }

    // public static int getNext(int n) {
    //     int sum = 0;
    //     // 逐个实现每一位数的平方和，妙哉~
    //     while (n > 0) {
    //         int d = n % 10;
    //         sum += d * d;
    //         n = n / 10;
    //     }
    //     return sum;
    // }

    // 快慢指针
    public boolean isHappy(int n) {
        int slowRunner = n;
        int fastRunner = getNext(n);
        while (fastRunner != 1 && slowRunner != fastRunner) {
            slowRunner = getNext(slowRunner);
            fastRunner = getNext(getNext(fastRunner));
        }
        return fastRunner == 1;
    }

    public int getNext(int n) {
        int totalSum = 0;
        while (n > 0) {
          int d = n % 10;
          n = n / 10;
          totalSum += d * d;
        }
        return totalSum;
    }
}
```

